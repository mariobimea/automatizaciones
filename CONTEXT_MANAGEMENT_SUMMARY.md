# NOVA Context Management - Executive Summary

## Files Created
1. **CONTEXT_MANAGEMENT_ANALYSIS.md** (1,026 lines)
   - Comprehensive technical analysis of all context flow mechanisms
   - Line-by-line code references
   - Detailed issue identification

2. **CONTEXT_FLOW_DIAGRAMS.md** (Diagrams)
   - Visual representations of all flows
   - ASCII diagrams for easy understanding
   - State transitions

---

## Key Findings

### 1. Three-Layer Context System

NOVA uses three distinct but connected layers for managing state:

```
Layer 1: WORKFLOW LEVEL (GraphEngine)
    └─ ContextManager
       - Simple dict-like API
       - Passed by reference between nodes
       - Lives in-memory during execution
       - Contains LIVE workflow state

Layer 2: NODE LEVEL (CachedExecutor Orchestrator)
    └─ ContextState
       - Tracks initial + current + data_insights
       - initial stays frozen (for OutputValidator comparison)
       - current gets mutated by E2B execution only
       - Lives during CachedExecutor.execute()

Layer 3: DATABASE LEVEL (Permanent Audit Trail)
    └─ ChainOfWork + ChainOfWorkStep
       - Immutable snapshots at EACH node
       - Granular traces at EACH agent
       - Permanent storage for audit/compliance
       - Cannot be affected by future mutations
```

### 2. Context Flow Between Nodes (Simplified)

```
Node A                          Node B
├─ Input: {"a": 1}            ├─ Input: {"a": 1, "b": 2}
├─ Execute & update:          │  ↑ Gets output from Node A
│  context.update({"b": 2})   │
├─ Output: {"a": 1, "b": 2}   ├─ Execute & update:
└─                            │  context.update({"c": 3})
                              ├─ Output: {"a": 1, "b": 2, "c": 3}
                              └─
```

**Key mechanism**: ContextManager is passed by reference
```python
context = ContextManager(initial_context)
while current_node_id is not None:
    metadata = await self._execute_node(current_node, context, ...)
    # context is MUTATED in-place by executor.execute()
```

### 3. Context Within a Node (Multi-Agent)

For CachedExecutor nodes, context flows through 6 agents:

```
InputAnalyzer → DataAnalyzer → CodeGenerator → CodeValidator → E2BExecutor → OutputValidator
    ↓               ↓                ↓              ↓              ↓              ↓
  read-only   read/maybe       read-only       read-only      READ+WRITE     read-only
  (context)   write (insights) (schema)        (validates)    (ONLY)         (before/after)
```

**Critical constraint**: Only E2BExecutor can mutate context
- All other agents READ context
- OutputValidator compares before/after but doesn't modify

### 4. AI Context Update Enforcement

CodeGenerator receives explicit instructions in prompt:

**For ActionNode:**
```python
# Generate code that prints:
context_updates = {'new_key': value}  # ONLY changes
print(json.dumps({
    "status": "success",
    "context_updates": context_updates
}))
```

**For DecisionNode:**
```python
# MUST set this specific key:
context['branch_decision'] = 'true' or 'false'
# Then print same format as ActionNode
```

**Enforcement layers:**
1. ✅ Prompt instructions (explicit rules)
2. ✅ Output format validation (JSON structure check)
3. ✅ Retry with error feedback (failed attempts show errors)
4. ✅ Post-execution check (GraphEngine validates decision_result set)

### 5. What Gets Stored in Chain of Work

Two-level storage:

**ChainOfWork (Node-level)** - One row per node
```
input_context    → Snapshot BEFORE execution
output_result    → Snapshot AFTER execution
code_executed    → Code that ran (AI-generated or hardcoded)
ai_metadata      → {model, attempts, errors, timings, total_time_ms}
decision_result  → For DecisionNode: "true"/"false"
path_taken       → For DecisionNode: next node ID
status           → "success" or "failed"
error_message    → If failed
```

**ChainOfWorkStep (Agent-level)** - Multiple rows per node
```
step_number      → 1-6 (which agent in sequence)
agent_name       → "InputAnalyzer", "CodeGenerator", etc.
attempt_number   → 1-3 (retry number)
input_data       → What agent received
output_data      → What agent returned
generated_code   → Code generated by agent
model_used       → AI model used ("gpt-4o-mini", "gpt-4o")
tokens_input     → Input tokens consumed
tokens_output    → Output tokens generated
cost_usd         → Cost of this agent execution
status           → "success" or "failed"
execution_time_ms → How long agent took
```

### 6. Snapshot Safety Pattern

```python
# BEFORE node execution
input_context = context.snapshot()  # DEEP COPY - immutable

# Node executes, context is mutated
context.update({"new_key": "value"})

# AFTER node execution  
output_result = context.snapshot()  # DEEP COPY - immutable

# Store both snapshots in database
# Future mutations to context do NOT affect stored snapshots
# (because they are deep copies)
```

**Why this matters:**
- Historical data cannot be corrupted
- Audit trail is provably accurate
- Debugging shows exact state at each step

---

## Issues Identified

### 1. ⚠️ Context Merge Ambiguity (Low Risk)

**Problem**: Output can be either format A or B
```python
# Format A: Direct context
{"key": "value"}

# Format B: Wrapped context  
{"context_updates": {"key": "value"}, "status": "success"}
```

**Current handling**:
```python
if "context_updates" in updated_context:
    context.update(updated_context.get("context_updates", {}))
else:
    context.update(updated_context)
```

**Mitigation**: Prompt tells AI to always use Format B. But orchestrator handles both for backward compatibility.

---

### 2. ⚠️ branch_decision Not Cleared (Medium Risk)

**Problem**: If a previous ActionNode accidentally sets `context['branch_decision']`, DecisionNode will read the stale value

```python
# Node A (ActionNode) - WRONG!
context['branch_decision'] = 'true'

# Node B (DecisionNode) - STALE!
decision_result = context.get("branch_decision")  # Reads 'true' from Node A
```

**Current safeguard**: Prompt tells code to only output changed keys. But no explicit clearing.

**Recommendation**: Before each DecisionNode execution:
```python
context.delete('branch_decision')  # Force fresh decision
```

---

### 3. ⚠️ Snapshot Size Explosion (Low Risk)

**Problem**: Large PDFs/files in base64 get deep-copied multiple times

```
1 node with 50MB PDF:
  - input_context snapshot: 50MB
  - output_result snapshot: 50MB+
  - Agent input_data: ~summarized
  - Total: 100MB+ stored per node
```

**Mitigation in place**:
- Orchestrator summarizes large values
- Strings > 200 chars shown as: `"<string: 50000000 chars>"`
- Agent steps store summaries, not full data

**Risk**: If someone disables summarization, DB bloats rapidly. Currently working as designed.

---

### 4. ✅ Error Metadata Properly Preserved

**Problem** (hypothetical): Generated code lost if E2B fails

**Actual behavior**: E2BExecutor raises CodeExecutionError with generated_code attached
```python
# GraphEngine extracts from ExecutorError
if isinstance(original_error, ExecutorError):
    code_to_save = original_error.generated_code
    
# Stores in ChainOfWork even for failed nodes
```

**Status**: Already handled ✓

---

## Critical Success Patterns

### Pattern 1: Execution Metadata Separation

```python
# IN-MEMORY: Context flows to next node
context.update(updated_context)

# IN-MEMORY: Metadata stays separate
ai_metadata = updated_context.pop("_ai_metadata", None)

# DATABASE: Both stored separately
ChainOfWork(
    input_context=input_context,
    output_result=output_result,
    ai_metadata=ai_metadata
)
```

This separation ensures:
- Next node gets clean context (no metadata pollution)
- Metadata is complete and accurate
- Chain of Work has full trace

### Pattern 2: Immutable Snapshots

```python
# Deep copy PREVENTS future mutations
input_context = context.snapshot()  # copy.deepcopy()
context.update({"pdf_path": "/new/path"})
# input_context STILL has original value
# Because it's a deep copy, not a reference
```

### Pattern 3: Orchestrator Update Only

```python
# E2B returns ONLY updates
{"amount": 1200, "vendor": "ACME"}

# Orchestrator merges (doesn't replace)
context_state.current.update(updates)

# Preserves existing keys:
# {"pdf_path": "...", "amount": 1200, "vendor": "ACME"}
```

---

## Recommendations

### 1. **Clear branch_decision Before DecisionNode** (Priority: Medium)

**Where**: `GraphEngine._execute_node()` before DecisionNode execution

```python
elif isinstance(node, DecisionNode):
    # Ensure fresh decision (no stale values from previous nodes)
    context.delete('branch_decision')
    
    updated_context = await executor.execute(...)
```

### 2. **Document Context Contract** (Priority: High)

Create internal documentation for node developers:
- What each node type should do with context
- What NOT to do (e.g., don't set branch_decision in ActionNode)
- Examples of correct context updates

### 3. **Add Context Validation Hook** (Priority: Medium)

Before persisting to ChainOfWork:
```python
# Validate that context is JSON-serializable
# Check for suspicious keys (e.g., _reserved_keys)
# Warn if context size > threshold
```

### 4. **Monitor Step Extraction** (Priority: Low)

Periodically check that steps are properly extracted:
```python
# Ensure no duplication of steps in ChainOfWorkStep
# Ensure _steps removed from ai_metadata before saving
```

---

## Summary Statistics

| Aspect | Count | Status |
|--------|-------|--------|
| **Context layers** | 3 | Well-architected |
| **Enforcement mechanisms** | 4+ | Strong |
| **Issues identified** | 4 | 1 High-priority (cleared by design), 1 Medium |
| **Safeguards in place** | 7+ | Comprehensive |
| **Code locations** | 8+ | Well-organized |
| **Database models** | 2 | Comprehensive (node + agent level) |
| **AI agents** | 6 | Coordinated via orchestrator |
| **Retry attempts** | 3 | Max, with error feedback |

---

## Files Analyzed

```
/nova/src/core/engine.py               (791 lines) - Main execution
/nova/src/core/context.py              (225 lines) - ContextManager
/nova/src/core/nodes.py                (319 lines) - Node definitions
/nova/src/core/executors.py            (742 lines) - Executor strategies
/nova/src/core/agents/orchestrator.py  (481 lines) - Multi-agent coordination
/nova/src/core/agents/state.py         (102 lines) - State management
/nova/src/core/agents/base.py          (98 lines) - Base agent class
/nova/src/models/chain_of_work.py      (86 lines) - Node audit trail
/nova/src/models/chain_of_work_step.py (421 lines) - Agent audit trail
```

---

## Conclusion

NOVA's context management system is **mature and well-designed**:

✅ **Clear separation of concerns**
- Workflow level (ContextManager)
- Node level (ContextState + Orchestrator)
- Database level (ChainOfWork snapshots)

✅ **Strong AI enforcement**
- Explicit prompt instructions
- Output format validation
- Retry with error feedback
- Post-execution checks

✅ **Comprehensive audit trail**
- Node-level snapshots
- Agent-level granular traces
- Immutable database records
- Full error history

✅ **Safe context mutation**
- Only E2B mutates context
- All other agents read-only
- Deep snapshots prevent data corruption
- Merge pattern preserves existing keys

⚠️ **Minor risks identified and documented**
- branch_decision not cleared (fixable)
- Output format ambiguity (handled)
- Database bloat (summarization in place)

**Overall assessment**: Production-ready with recommendations for monitoring and documentation.

